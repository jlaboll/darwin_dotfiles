#!/bin/sh

# Core dotfiles functions
# Provides shell detection and initialization functions

# Returns TRUE (exit code 0) if the default shell is bash, FALSE otherwise
# Uses macOS Directory Services (dscl) for reliable detection, falls back to $SHELL
# Usage: if is_shell_bash; then ...
function is_shell_bash() {
    local default_shell=""
    
    # Try dscl first (most reliable on macOS)
    if command -v dscl >/dev/null 2>&1; then
        default_shell=$(dscl . -read /Users/$USER UserShell 2>/dev/null | awk '{print $2}')
    fi
    
    # Fallback to $SHELL environment variable if dscl didn't work
    if [[ -z "$default_shell" ]]; then
        default_shell="$SHELL"
    fi
    
    # Return TRUE (0) if bash, FALSE (1) otherwise
    if [[ "$default_shell" == *"bash"* ]]; then
        return 0
    else
        return 1
    fi
}

# Initializes the dotfiles in user home directory
# Appends content from links/ directory to ~/.filename within a managed section
# If the managed section already exists, it is replaced with updated content
# User customizations outside the managed section are preserved
# Then sources the appropriate profile file based on default shell
# Requires: DOTFILES_ROOT must be set
# Usage: dotfiles_init
function dotfiles_init() {
  local txt_path_to_dotfiles=$(cd $DOTFILES_ROOT && pwd)
  local txt_rc_files="$txt_path_to_dotfiles/links/*"
  local txt_rc_file=""
  
  # Marker comments for managed section - DO NOT CHANGE THESE
  local MARKER_START="# >>> DOTFILES MANAGED SECTION - DO NOT EDIT THIS LINE >>>"
  local MARKER_END="# <<< DOTFILES MANAGED SECTION - DO NOT EDIT THIS LINE <<<"

  # Helper function to update managed section in destination file
  # If destination exists with markers: replaces the managed section
  # If destination exists without markers: appends managed section
  # If destination doesn't exist: creates file with managed section
  function link_file () {
    local txt_source="$1"
    local txt_file_name=$(basename "$txt_source")
    local txt_dest="$HOME/.$txt_file_name"
    
    # Read source content
    local source_content
    source_content=$(cat "$txt_source")
    
    # Build the managed block with informative header
    local managed_header="# Generated by darwin_dotfiles - content below is SAFE TO MODIFY.
# Your changes will be preserved until the next run of \`up\`.
# To update from source, run: \`up\`
# WARNING: Do not edit or remove the marker lines above/below."

    if [[ -f "$txt_dest" ]]; then
      # Check if managed section already exists
      if grep -qF "$MARKER_START" "$txt_dest" && grep -qF "$MARKER_END" "$txt_dest"; then
        # Replace existing managed section
        local temp_file replacement_file
        temp_file=$(mktemp)
        replacement_file=$(mktemp)
        
        # Write replacement content to temp file
        printf '%s\n%s\n%s\n%s\n' "$MARKER_START" "$managed_header" "$source_content" "$MARKER_END" > "$replacement_file"
        
        # Use awk to replace the section between markers (inclusive)
        awk -v startm="$MARKER_START" -v endm="$MARKER_END" -v repfile="$replacement_file" '
          $0 == startm { 
            skip=1
            while ((getline line < repfile) > 0) print line
            close(repfile)
            next
          }
          $0 == endm { skip=0; next }
          !skip { print }
        ' "$txt_dest" > "$temp_file"
        
        rm "$replacement_file"
        mv "$temp_file" "$txt_dest"
        echo "Updated managed section in $txt_dest"
      else
        # Append managed section to existing file
        printf '\n%s\n%s\n%s\n%s\n' "$MARKER_START" "$managed_header" "$source_content" "$MARKER_END" >> "$txt_dest"
        echo "Appended managed section to $txt_dest"
      fi
    else
      # Create new file with managed section
      printf '%s\n%s\n%s\n%s\n' "$MARKER_START" "$managed_header" "$source_content" "$MARKER_END" > "$txt_dest"
      echo "Created $txt_dest with managed section"
    fi
  }

  # Process all files from links directory
  for txt_rc_file in $txt_rc_files; do
    link_file "$txt_rc_file"  
  done

  # Source the appropriate profile based on default shell
  if is_shell_bash; then 
    source ~/.bash_profile
  else
    source ~/.zsh_profile
  fi

  echo "Shell setup complete."
}
